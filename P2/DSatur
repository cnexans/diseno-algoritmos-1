ResultadoGrafo algoritmoDsatur(Grafo::Grafo * graph){

	clock_t t_ini, t_fin;
	double secs;
	t_ini = clock();
  
  	//Vector de nodos que se irá llenando con los nodos a los que ya se le haya asignado 
  	//un color
	std::vector <Nodo::Nodo *> nodos_aux;
	//Ordenar el conjunto de nodos tomando en cuenta sus grados de adyacencia
	sort ((graph->_nodos).begin(), (graph->_nodos).end(), compGradoAdyNodo);
	(graph->_nodos)[0]->SetColor(1);	
	nodos_aux.push_back((graph->_nodos)[0]);
	
	(graph->_nodos).erase((graph->_nodos).begin());
	
	if(graph->verticesSinColor()){
		do{
			//Ordenar el conjunto de nodos tomando en cuenta el grado de color del nodo
		   sort ((graph->_nodos).begin(), (graph->_nodos).end(), compGradoColorNodo);	
			int grado_max = (graph->_nodos)[0]->GetGradoAdy();
			int numNodGrado = 1;
			for( int i = 0;i <  (graph->_nodos).size(); i++){
				if((graph->_nodos)[i]->GetGradoAdy() == grado_max ) 
					numNodGrado++;
			}
			sort((graph->_nodos).begin(),(graph->_nodos).begin() + numNodGrado - 1,compGradoAdyNodo);			
			//Luego de ordenar los nodos, se colorean en ese orden con el mínimo color posible
			int min_color = obtenerColorMinimo((graph->_nodos)[0]);
			(graph->_nodos)[0]->SetColor(min_color);
			nodos_aux.push_back((graph->_nodos)[0]);
			
			(graph->_nodos).erase((graph->_nodos).begin());
		} while(graph->verticesSinColor());
	}
	  
	t_fin = clock();
	secs = (double)(t_fin - t_ini) / CLOCKS_PER_SEC;
   ResultadoGrafo resultado = {secs * 1000.0, nodos_aux,graph->GetNombre(),graph->GetNombreSolucion()} ;

   return resultado;

}