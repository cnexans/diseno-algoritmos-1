\documentclass[a4paper,10pt]{article}
\usepackage{algorithm}
\usepackage{algorithmic}
\input{sa.tex}
%\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\title{}
\author{}
\date{}
\pdfinfo{%
  /Title    (Diseño de Algoritmos - Proyecto 1)
  /Author   (Fabio Castro, Leopoldo Pimentel)
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}
\begin{document}
\maketitle
\section{Problema 1}
\subsection{Análisis de Complejidad}
  \hspace{2cm}Para el analisis de este algoritmo, lo podemos dividir  en varias subpartes.
  La primera parte, seria la lectura de cada una de las pruebas.
  Esta lectura, es de orden {$O(n)$}, que que presenta un ciclo de tamaño {$N$}
  La segunda parte es la creacion de cada uno de los arcos posibles
  Esta, creacion, es de orden {$O(n^2)$}, ya que recorre la lista 
  en orden cuadratico para conseguir generar todos los arcos posibles
  Se usa un algorimo de ordenamiento que viene con el lenguaje. Este algoritmo su complejidad es de {$O(nlogn)$}
  La tercera parte y mas compleja es una busqueda de las componentes conexas.
  Esta trabaja con una lista y su recorrido de orden {$O(n)$}
  y adicionalmente, unas consultas. Y una busqueda en otra lista.
  Cada busqueda es de orden {$O(componentes_conexas)$}. Es decir que la busqueda es sobre un 
  grafo mucho mas pequeño que {$N$}, por consiguiente, podriamos considerar que esta tercera 
  parte es de orden {$O(n)$}
\subsection{Psucódigo}
\begin{algorithm}                      % enter the algorithm environment
\caption{Calcular maxima cantidad de cable normal y cable especial para que sea mínimo en costo y todos los nodos se encuentren conectados}          % give the algorithm a caption
\label{Problema 1}                           % and a label for \ref{} commands later in the document
\begin{algorithmic}[1]                    % enter the algorithmic environment
\REQUIRE {$C$ Conjunto de Pares que contienen las coordenadas de los nodos, $M$ Maxima cantidad de metros a tarifa1, $T1$ Tarifa 1, $T2$ Tarifa 2, $MO$ Cantidad de Modems}
    \ENSURE Par que contiene en la primera posicion la cantidad de cable normal, y en la segunda cantidad de cable especial.
    \STATE entero {$componentesconexas$} = {$C$.size() - $M$}
    \STATE $par < entero , entero >  salida $ 
    \STATE entero $tarifa$ = 0
    \STATE entero $costototalt1$ = 0
    \STATE entero $costototalt2$ = 0
    \STATE pila {$q$} = {\bf DistanciasYCostos}{({$C$})}
    \COMMENT{La cola esta ordena por menor costo}
    \STATE $par < par < entero , entero > , entero > elemento e$
    \FOR  {$entero$ $x = 0$ ; $entero$ $<$ $q.size()$ \bf y $componentesconexas$ $>$ $0$ ; $x=x+1$} 
      \STATE $elemento$ = $q.pop$
        \IF { $find(elemento.primero.primero)$ diferente $find(elemento.primero.segundo)$}
	  \STATE $tarifa = elemento.segundo$
	  \IF {$distancia(elemento.primero.primero,elemento.primero.segundo) > M$}
	    \STATE $costototalt1  = costototalt1 + tarifa$
	  \ELSE	
	    \STATE $costototalt2 = costototalt2 + tarifa$
	  \ENDIF
	  \STATE $componentesconexas = componentesconexas - 1$
	\ENDIF
    \ENDFOR
    \RETURN {$<costototalt1,costototalt2>$}
\end{algorithmic}
\end{algorithm}
\subsection{Explicación de la solución dada}
\section{Problema 2}
\subsection{Análisis de Complejidad}
\hspace{2cm}Este Algoritmo se parece mucho al primero, este tiene
un while de orden {$O(n)$}, pero es depreciado porque este {$N$}
representa la cantidad de pruebas y no deberia ser un numero muy 
grande.
Despues, internamente exiten 3 ciclos, cada uno de orden {$O(n)$}
Cada uno de estos ciclos, son ciclos de lectura y de acomodacion de datos.
Su complejidad no es muy grande para números pequeños, pero se podría complicar
para números muy grandes o para pruebas con números muchos mas grandes.
El siguiente ciclo, es un for externo que llama a una funcion Unir internamente 
El ciclo es de orden {$O(n)$}, luego la funcion de interna, tiene una llamada a otra
funcion auxiliar que es recursiva. Esta funcion recursiva tambien tiene un comportamiendo de orden {$O(n)$}
ya que se sabe que nunca sera mayor que N Podriamos decir entonces, que este ciclo, 
y por consiguiente la funcion interna tienen orden {$O(n^{2})$}, ya que hay un ciclo interno 
y otro externo que estan ciclando y uno depende el otro.
Por ultimo, quedan dos ciclos, cada uno de orden {$O(n)$}, son ciclos de recorrido de los vectores. 
Tomando en consideracion todos estos ordenes internos a nuestro algoritmo, podemos decir 
que nuestro algoritmo se comporta en el peor caso como un algoritmo de orden {$O(n^{2})$}
\subsection{Psucódigo}
\begin{algorithm}                      % enter the algorithm environment
\caption{Calcular $total$, que es el total de actividades que puede realizar el empleado}          % give the algorithm a caption
\label{Problema 2}                           % and a label for \ref{} commands later in the document
\begin{algorithmic}[1]                    % enter the algorithmic environment
    \REQUIRE {$C$ Cantidad de tareas, $A$ Lista de tuplas de actividades}
    \ENSURE Entero que indica la cantidad maxima de actividades que puede realizar
    \STATE entero {$ultimo = -1$}
    \RETURN {$ total $}
\end{algorithmic}
\end{algorithm}
\subsection{Explicación de la solución dada}
\section{Tercer problema}
\subsection{Análisis de Complejidad}
\hspace{0.5cm}Primera parte es una lectura de la cantidad de pruebas que tiene el caso.
  Esta primera parte es {$O(n)$}, ya que es un ciclo de tamaño {$N$}.
  Luego, tenemos para cada empleado un ciclo por el numero de actividades que este realizara.
  Este ciclo es de tamaño n, por consiguiente, el proceso es {$O(n)$}
  Se usa un algorimo de ordenamiento que viene con el lenguaje. Este algoritmo su complejidad es de {$O(nlogn)$}
  Por ultimo, se realiza un ciclo de tamaño N, este ciclo tiene una complejidad de {$O(n)$}
  Como tenemos el primer ciclo por afuera, y todos los demas internos, podriamos pensar que entonces 
  la complejidad del problema es de {$ O(n^{2}log N)$}. 
  Pero, al ser el primer ciclo un ciclo de iteraciones de pruebas, donde el numero no sera muy grande, 
  podriamos pensar entonces que la complejidad de todo el algoritmo es la complejidad mas grande. 
  Esta seria {$O(nlogN)$} 
\subsection{Psucódigo}
\begin{algorithm}                      % enter the algorithm environment
\caption{Calcular maxima cantidad de cable normal y cable especial para que sea mínimo en costo y todos los nodos se encuentren conectados}          % give the algorithm a caption
\label{Problema 1}                           % and a label for \ref{} commands later in the document
\begin{algorithmic}[1]                    % enter the algorithmic environment
\REQUIRE {$N$ Conjunto de Nodos, $Q$ Lista de Querys, $C$ Cantidad de Arcos Originales, $G$ Lista de Arcos, $H$ Arcos a Eliminar }
    \ENSURE Lista de respuesta de los Querys
    \STATE entero $total$
    \STATE lista $< entero > salida$
    \FOR  {cada $elemento \in G$ y $elemento \notin H$} 
      \STATE {unir$(elemento.primero,elemento.segundo)$}
    \ENDFOR
    \
    \RETURN {$<costototalt1,costototalt2>$}
\end{algorithmic}
\end{algorithm}
\subsection{Explicación de la solución dada}
\end{document}
